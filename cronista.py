# cronista.py (Versi√≥n con l√≥gica de prioridad)
import yaml
import json
import random
import re
from datetime import datetime, timedelta
from config import GEMINI_API_KEY
import google.generativeai as genai

# --- INICIALIZACI√ìN Y CONFIGURACI√ìN ---
gemini_model = None
if GEMINI_API_KEY:
    try:
        genai.configure(api_key=GEMINI_API_KEY)
        gemini_model = genai.GenerativeModel('gemini-1.5-flash')
        print("INFO: Modelo de IA Gemini configurado correctamente.")
    except Exception as e:
        print(f"ADVERTENCIA: No se pudo configurar la API de Gemini. Error: {e}")
else:
    print("ADVERTENCIA: No se encontr√≥ GEMINI_API_KEY.")

PALABRAS_CLAVE_INTERES = [
    'ficho', 'fichaje', 'oferta', 'ofrezco', 'vendo', 'venta', 'compro', 
    'compra', 'clausula', 'clausulazo', 'mercado', 'millones', 'pasta', 
    'puja', 'pujar', 'vendido', 'paquete', 'manco', 'robo', 'tongo', 'suerte', 
    'lloron', 'malo', 'malisimo', 'gano', 'gane', 'reviento', 'paliza', 'lider',
    'lesion', 'lesionado', 'roto', 'banquillo', 'alineacion', 'tactica'
]

PERSONALIDADES = {}
try:
    with open('comentaristas.yml', 'r', encoding='utf-8') as f:
        PERSONALIDADES = yaml.safe_load(f).get('comentaristas', {})
    print(f"INFO (Cronista): Cargados {len(PERSONALIDADES)} comentaristas desde 'comentaristas.yml'.")
except FileNotFoundError:
    print("ERROR (Cronista): El archivo 'comentaristas.yml' no fue encontrado.")
except Exception as e:
    print(f"ERROR (Cronista): No se pudo leer o procesar 'comentaristas.yml'. Error: {e}")

def limpiar_nombre_para_ia(nombre):
    """ Elimina emojis y caracteres que puedan dar problemas a la IA. """
    if not isinstance(nombre, str):
        return ""
    # Mantenemos letras, n√∫meros, espacios y guiones bajos/medios.
    return ''.join(c for c in nombre if c.isalnum() or c.isspace() or c in ['-', '_']).strip()
# --- FUNCI√ìN CLAVE: EL SELECTOR INTELIGENTE ---

def elegir_comentarista(contexto_actual):
    if not PERSONALIDADES: return None
    candidatos = []
    pesos = []
    for key, data in PERSONALIDADES.items():
        if contexto_actual in data.get("roles_asignados", {}):
            candidatos.append(data)
            pesos.append(data["roles_asignados"][contexto_actual])
    if not candidatos: return None
    return random.choices(candidatos, weights=pesos, k=1)[0]
# --- FUNCIONES AUXILIARES PARA LA L√ìGICA DE PRIORIDAD ---

def _find_root_message(message_id, declarations_map):
    current_id = message_id
    while True:
        message = declarations_map.get(current_id)
        if not message or not message.get("reply_to_message_id"): break
        parent_id = message["reply_to_message_id"]
        if parent_id not in declarations_map: break
        current_id = parent_id
    return current_id

def _group_declarations_into_threads(all_declarations):
    declarations_map = {d["message_id"]: d for d in all_declarations if d.get("message_id")}
    threads = {}
    for declaration in all_declarations:
        if not declaration.get("message_id"): continue
        root_id = _find_root_message(declaration["message_id"], declarations_map)
        if root_id not in threads: threads[root_id] = []
        threads[root_id].append(declaration)
    for root_id in threads: threads[root_id].sort(key=lambda d: d["timestamp"])
    return list(threads.values())

def _buscar_declaracion_reciente(manager_ids, todas_declaraciones, ids_ya_usadas):
    fecha_limite = datetime.now() - timedelta(days=7)
    if not isinstance(manager_ids, list): manager_ids = [manager_ids]
    for d in sorted(todas_declaraciones, key=lambda x: x['timestamp'], reverse=True):
        if d.get("telegram_user_id") in manager_ids and d.get("message_id") not in ids_ya_usadas and datetime.fromisoformat(d['timestamp']) > fecha_limite:
            return d
    return None

# --- FUNCIONES DE GENERACI√ìN DE TEXTO (ACTUALIZADAS) ---

def generar_introduccion_semanal(perfiles, todas_declaraciones, jornada_actual):
    """
    PRIORIDAD ALTA: Busca conversaciones jugosas.
    DEVUELVE: una tupla (texto_generado, set_de_ids_usados)
    """
    if not gemini_model:
        return ("## üéôÔ∏è El Vestuario Habla\n\n_El Cronista est√° af√≥nico._\n", set())

    todos_los_hilos = _group_declarations_into_threads(todas_declaraciones)
    hilos_relevantes = []
    ids_usados = set()
    fecha_limite = datetime.now() - timedelta(days=7)

    for hilo in todos_los_hilos:
        actividad_reciente = any(datetime.fromisoformat(d['timestamp']) > fecha_limite for d in hilo)
        if not actividad_reciente: continue

        if any(palabra in d.get('declaracion', '').lower() for d in hilo for palabra in PALABRAS_CLAVE_INTERES):
            hilos_relevantes.append(hilo)
            for d in hilo: ids_usados.add(d['message_id'])

    if not hilos_relevantes:
        return ("## üéôÔ∏è El Vestuario Habla\n\n_Semana de calma tensa._\n", set())

    transcripcion = ""
    for i, hilo in enumerate(hilos_relevantes):
        transcripcion += f"--- Hilo de Conversaci√≥n {i+1} ---\n"
        for d in hilo:
            prefijo = "  -> (en respuesta) " if d.get("reply_to_message_id") else ""
            transcripcion += f"{prefijo}- {d['nombre_mister']}: \"{d['declaracion']}\"\n"
        transcripcion += "---\n\n"

    lider_actual = sorted(perfiles, key=lambda p: p['historial_temporada'][-1]['puesto'])[0]
    prompt = f"""
    Eres el Editor Jefe de un programa deportivo. Tu misi√≥n es escribir una introducci√≥n impactante para el reporte de la Jornada {jornada_actual}.
    Te presento las conversaciones m√°s "calientes" de la semana. Los mensajes con "->" son respuestas.
    {transcripcion}
    Dato clave: El l√≠der actual es {lider_actual['nombre_mister']}.
    Elige la conversaci√≥n m√°s jugosa y realiza dos tareas:
    1.  **Escribe un T√çTULO DE LA JORNADA:** Una frase corta y potente.
    2.  **Escribe un P√ÅRRAFO DE AN√ÅLISIS:** Comenta el hilo m√°s significativo.
    Tu respuesta debe tener el formato:
    T√çTULO: [Tu t√≠tulo aqu√≠]
    AN√ÅLISIS: [Tu p√°rrafo de an√°lisis aqu√≠]
    """
    try:
        print(" -> Generando introducci√≥n (Prioridad Alta)...")
        response = gemini_model.generate_content(prompt)
        titulo = "El Vestuario Habla"
        analisis = response.text
        match_titulo = re.search(r"T√çTULO: (.*)", response.text, re.IGNORECASE)
        match_analisis = re.search(r"AN√ÅLISIS: (.*)", response.text, re.IGNORECASE | re.DOTALL)
        if match_titulo: titulo = match_titulo.group(1).strip()
        if match_analisis: analisis = match_analisis.group(1).strip()
        return (f"## üéôÔ∏è {titulo}\n\n_{analisis}_\n", ids_usados)
    except Exception as e:
        print(f"Error al generar la introducci√≥n de la IA: {e}")
        return ("## üéôÔ∏è El Vestuario Habla\n\n_El Cronista tuvo problemas t√©cnicos._\n", set())

def generar_cronica(perfil_manager, datos_actuales, nombre_rival, todas_declaraciones, ids_ya_usadas, comentarista):
    # ANTES: Ten√≠a un prompt fijo y se llamaba en bucle.
    # AHORA: Recibe un 'comentarista' elegido una sola vez fuera del bucle para dar coherencia.
    if not gemini_model or not comentarista: return "El cronista est√° af√≥nico hoy."
    
    declaracion_reciente = _buscar_declaracion_reciente(perfil_manager.get("telegram_user_id"), todas_declaraciones, ids_ya_usadas)
    ultima_declaracion = declaracion_reciente['declaracion'] if declaracion_reciente else "ha mantenido un prudente silencio esta semana."
    nombre_mister = perfil_manager.get('nombre_mister', 'Desconocido')

    prompt = (
        f"{comentarista['prompt_base']}\n\n"
        f"Analiza al m√°nager: {nombre_mister}\n"
        f"Puntos esta jornada: {datos_actuales.get('puntos_jornada', 0)}\n"
        f"Su √∫ltima declaraci√≥n: \"{ultima_declaracion}\"\n\n"
        f"Misi√≥n: Escribe una cr√≥nica breve (2-3 frases), conectando su rendimiento con su declaraci√≥n."
    )
    try:
        response = gemini_model.generate_content(prompt)
        return response.text.strip()
    except Exception as e:
        print(f"Error al generar cr√≥nica para {nombre_mister}: {e}")
        return "El cronista se ha quedado sin palabras."

# --- OTRAS FUNCIONES DE CRONISTA (PUEDEN QUEDAR IGUAL O ADAPTARSE EN EL FUTURO) ---
# Por ahora, las funciones de Sprints y Parejas no usar√°n declaraciones para simplificar.
# Si en el futuro quieres a√±adirles contexto, seguir√≠an el mismo patr√≥n que 'generar_cronica'.

def generar_comentario_premio(nombre_premio, ganadores, jornada_actual, es_final):
    comentarista = elegir_comentarista('premio')
    if not gemini_model or not comentarista: return "_El cronista guarda silencio._"
    contexto = "de forma definitiva" if es_final else f"provisionalmente en la jornada {jornada_actual}"
    nombres = " y ".join([limpiar_nombre_para_ia(g) for g in ganadores])
    prompt = (f"{comentarista['prompt_base']}\n\nNarra la entrega del premio '{nombre_premio}'. El ganador es '{nombres}' y lo ha conseguido {contexto}. Comenta este logro de forma breve y memorable.")
    print(f" -> Pidiendo comentario para '{nombre_premio}' a '{comentarista['nombre_display']}'...")
    try: return f"_{gemini_model.generate_content(prompt).text.strip()}_"
    except Exception as e: print(f"ERROR en IA para Premio '{nombre_premio}': {e}"); return f"_{comentarista['nombre_display']} aplaude el logro de {nombres}._"
    

def generar_comentario_sprint(nombre_sprint, clasificacion, jornada_actual, inicio_sprint, fin_sprint):
    comentarista = elegir_comentarista('sprint_analisis')
    if not gemini_model or not clasificacion or not comentarista: return "_El cronista toma tiempos._"
    if jornada_actual >= fin_sprint: estado_sprint = "y la carrera ha finalizado"
    elif jornada_actual == inicio_sprint: estado_sprint = "y la carrera acaba de empezar"
    else: estado_sprint = "y la carrera est√° en pleno apogeo"
    lider = clasificacion[0]
    narrativa = f"En el sprint '{nombre_sprint}', el m√°nager '{limpiar_nombre_para_ia(lider['nombre'])}' va en cabeza con {lider['puntos']} puntos {estado_sprint}."
    prompt = (f"{comentarista['prompt_base']}\n\nTe resumo la situaci√≥n de la carrera: {narrativa}. Genera un comentario de 2 frases.")
    print(f" -> Pidiendo an√°lisis de sprint a '{comentarista['nombre_display']}'...")
    try:
        response = gemini_model.generate_content(prompt)
        return f"_{response.text.strip()}_"
    except Exception as e:
        print(f"ERROR en IA para Sprint: {e}"); return "_Los m√°nagers aprietan el acelerador._"


# En cronista.py

# En cronista.py

# En cronista.py

def generar_nombre_equipo_ia_thread(perfiles_equipo, perfiles_todos, resultado_queue):
    # ANTES: Ten√≠a su propio prompt.
    # AHORA: Usa el selector con el contexto 'bautizo_equipo'.
    comentarista = elegir_comentarista('bautizo_equipo')
    if not gemini_model or not comentarista:
        nombre, justificacion = crear_nombre_emergencia(perfiles_equipo)
        resultado_queue.put({"nombre_equipo": nombre, "justificacion": justificacion})
        return
    
    contexto_general_liga = f"Contexto de la Liga: {len(perfiles_todos)} m√°nagers en total."
    descripcion_miembros = "\n".join(
        f"--- Perfil M√°nager {i+1} ---\n"
        f"Nombre: {p.get('nombre_mister', 'N/A')}\n"
        f"Lema: {p.get('apodo_lema', 'N/A')}\n"
        f"Estilo: {p.get('estilo_juego', 'N/A')}\n"
        for i, p in enumerate(perfiles_equipo)
    )

    prompt = (
        f"{comentarista['prompt_base']}\n\n"
        f"{contexto_general_liga}\n"
        f"Perfiles del equipo a bautizar:\n{descripcion_miembros}\n\n"
        "Analiza la combinaci√≥n de sus perfiles y crea un nombre ingenioso y una justificaci√≥n creativa."
    )
    print(f" -> Pidiendo bautizo de equipo a '{comentarista['nombre_display']}'...")
    try:
        response = gemini_model.generate_content(prompt)
        clean_response = response.text.strip().replace("```json", "").replace("```", "")
        ai_json = json.loads(clean_response)
        resultado_queue.put(ai_json)
    except Exception as e:
        print(f"     -> ERROR en el hilo de la IA: {e}")
        nombre, justificacion = crear_nombre_emergencia(perfiles_equipo)
        resultado_queue.put({"nombre_equipo": nombre, "justificacion": justificacion})

def crear_nombre_emergencia(perfiles):
    nombres = [p.get('nombre_mister', 'Manager').split()[0] for p in perfiles]
    return f"{' & '.join(nombres)} United", "El cronista estaba af√≥nico, as√≠ que fundaron su propio club."

## --- NUEVA FUNCI√ìN PARA COMENTAR PREMIOS --- ##
# --- 3. COMENTARIO DE PREMIOS ---
# --- COMENTARIO DE PREMIOS (MEJORADO) ---


def generar_comentario_parejas(clasificacion):
    comentarista = elegir_comentarista('parejas_analisis')
    if not gemini_model or not clasificacion or not comentarista: return "_El cronista estudia las sinergias._"
    if len(clasificacion) > 1:
        narrativa = f"El equipo '{limpiar_nombre_para_ia(clasificacion[0]['nombre'])}' lidera con {clasificacion[0]['media']} puntos, mientras que '{limpiar_nombre_para_ia(clasificacion[1]['nombre'])}' le sigue con {clasificacion[1]['media']}."
    else:
        narrativa = f"El equipo '{limpiar_nombre_para_ia(clasificacion[0]['nombre'])}' lidera en solitario con {clasificacion[0]['media']} puntos."
    prompt = (f"{comentarista['prompt_base']}\n\nResume la situaci√≥n por parejas: {narrativa}. Analiza brevemente.")
    print(f" -> Pidiendo an√°lisis de parejas a '{comentarista['nombre_display']}'...")
    try: return f"_{gemini_model.generate_content(prompt).text.strip()}_"
    except Exception as e: print(f"ERROR en IA para Parejas: {e}"); return "_Una alianza poderosa se est√° forjando._"
    



# En cronista.py

# --- LISTA DE PALABRAS CLAVE (EL "RADAR DEL SALSEO") ---
# Esta lista es fundamental. Puedes y debes ampliarla con el tiempo.
# Incluye abreviaturas, jerga, etc.

# Reemplaza tu funci√≥n generar_introduccion_semanal entera por esta:


    




# --- BLOQUE DE PRUEBA UNITARIA ---
# Este c√≥digo solo se ejecuta si lanzamos este archivo directamente
""" if __name__ == '__main__':
    print("--- INICIANDO PRUEBA UNITARIA DE LA INTRODUCCI√ìN ---")
    
    # 1. Cargamos las claves desde el .env (necesario para la IA)
    from dotenv import load_dotenv
    load_dotenv()
    
    # 2. Simulamos los datos que recibir√≠a la funci√≥n
    #    Cargamos los perfiles reales para que la prueba sea realista
    try:
        with open('perfiles.json', 'r', encoding='utf-8') as f:
            perfiles_de_prueba = json.load(f)
        jornada_de_prueba = 4 # Pon un n√∫mero de jornada cualquiera
        
        # 3. Llamamos a la funci√≥n que queremos probar
        introduccion = generar_introduccion_semanal(perfiles_de_prueba, jornada_de_prueba)
        
        # 4. Imprimimos el resultado
        print("\n--- RESULTADO GENERADO ---\n")
        print(introduccion)
        print("\n--- FIN DE LA PRUEBA ---")

    except FileNotFoundError:
        print("ERROR: Para probar, aseg√∫rate de que 'perfiles.json' y 'declaraciones.json' existen en esta carpeta.")
    except Exception as e:
        print(f"La prueba ha fallado con un error: {e}") """